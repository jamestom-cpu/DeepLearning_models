import numpy as np
from my_packages import spherical_coordinates

def electric_dipole_G_magnetic(unit_p, k, r, r0)-> np.ndarray:
    
    R = r[None, ...]-np.expand_dims(r0, [-1, -2, -3])
    norm_R = np.linalg.norm(R, axis=1)
    unit_r = R/np.expand_dims(norm_R, 1) # shape (n,x,y,z)

    coeff1 = 1j*k # shape (f) 

    kr = np.einsum("f,nxyz->nxyzf", k, norm_R)
 
    coeff2 = (np.ones_like(kr)-1j/kr)*np.exp(-1j*kr)/(4*np.pi*norm_R[...,None]) #shape (nxyzf)

    
    factor = np.einsum("f, nxyzf -> nxyzf", coeff1, coeff2)

    direction_vector = np.stack([- np.cross(unit_r0, unit_p0, axisa=0, axisb=0, axisc=0) for unit_r0, unit_p0 in zip(unit_r, unit_p)], axis=0) # (n3xyz)
    
    return np.einsum("nixyz,nxyzf->nixyzf", direction_vector, factor)


    

def inf_loop_G_electric(unit_m, k, mu, f, r, r0)-> np.ndarray:
    omega = 2*np.pi*f #size: (f)

    R = r[None, ...]-np.expand_dims(r0, [-1, -2, -3])
    norm_R = np.linalg.norm(R, axis=1)
    unit_r = R/np.expand_dims(norm_R, 1) # shape (n,x,y,z)

    coeff1 = omega*mu*k # shape (f) 

    kr = np.einsum("f,nxyz->nxyzf", k, norm_R)
 
    coeff2 = (np.ones_like(kr)-1j/kr)*np.exp(-1j*kr)/(4*np.pi*norm_R[...,None]) #shape (nxyzf)

    
    factor = np.einsum("f, nxyzf -> nxyzf", coeff1, coeff2)

    direction_vector = np.stack([- np.cross(unit_r0, unit_m0, axisa=0, axisb=0, axisc=0) for unit_r0, unit_m0 in zip(unit_r, unit_m)], axis=0) # (n3xyz)
    
    return np.einsum("nixyz,nxyzf->nixyzf", direction_vector, factor)



def inf_loop_electric_field(m, k, mu, f, r, r0):
    omega = 2*np.pi*f #size: (f)

    R = r[None, ...]-np.expand_dims(r0, [-1, -2, -3])
    norm_R = np.linalg.norm(R, axis=1)
    unit_r = R/np.expand_dims(norm_R, 1)

    coeff1 = omega*mu*k # shape (f)
    coeff1_1 = np.einsum("i,f->if", m, coeff1)
    
    kr = np.einsum("f,xyz->xyzf", k, R)
    coeff2 = (np.ones_like(kr)-1j/kr)*np.exp(-1j*kr)/(4*np.pi*R[...,None])

    factor = np.einsum("if, xyzf -> ixyzf", coeff1_1, coeff2)

    E = - np.cross(unit_r, factor, axisa=0, axisb=0, axisc=0)

    return E



def magnetic_greens_solution_for_moment_amplitude(k, r, r0, orientations, scale_with_wave_number=True):
    G = magnetic_greens_functions_solution_dyad(k,r,r0,scale_with_wave_number)
    spherical_directions = np.array([1, orientations[0], orientations[1]])
    unit_p = spherical_coordinates.to_cartesian_grid(spherical_directions)

    return np.einsum("j, j...", unit_p, G)

def magnetic_greens_functions_solution_dyad(k, r, r0, scale_with_wave_number=True):
    """
    From dyadic application of maxwell equations, for a uniform space properties, the magentic field 
    generated by a Hertial dipole is: H = k^2 <G(r-r0), m>. 

    For simplicity this function actually returns the k^2 G(r-r0) dyad. Therefore, the solution field can be 
    calculated by applying a dot multiplication over the FIRST dimension

    In order to solve for multiple frequencies, the wave factor is actually an array. The frequency dimension will be kept as the 
    rightmost frequency
    
    """
    r = np.array(r)[..., None]
    k = k[None, ...]

    R = np.subtract(np.transpose(r), r0).T
    norm_R = np.linalg.norm(R, axis=0)
    unit_r = R/norm_R

    g1 = 1 - 1j/(k*norm_R) - 1/(k*norm_R)**2
    g2 = -1 + 3j/(k*norm_R) + 3/(k*norm_R)**2

    exponential_component = np.exp(-1j*k*norm_R)/(4*np.pi*norm_R)

    # get dyadic components
    identity_dyadic = np.diag(np.ones(3)).reshape([3,3]+list(np.ones(len(norm_R.shape), dtype="int")))
    unit_rr_dyadic = np.einsum("i..., j...",unit_r, unit_r)
    unit_rr_dyadic = np.moveaxis(unit_rr_dyadic, [-1,-2], [0,1])

    green_solution_dyadic = exponential_component*(g1*identity_dyadic+g2*unit_rr_dyadic)


    return (green_solution_dyadic*k**2 if scale_with_wave_number else green_solution_dyadic)


def magnetic_dipole(k, p, r, r0):
    R = np.subtract(np.transpose(r), r0).T
    norm_R = np.linalg.norm(R, axis=0)
    unit_r = R/norm_R
    g1 = 1 - 1j/(k*norm_R) - 1/(k*norm_R)**2
    g2 = -1 + 3j/(k*norm_R) + 3/(k*norm_R)**2
    p = np.array(p).reshape(3,1,1,1)
    pdotr = np.einsum( "i,i...", p.squeeze(), unit_r)
    H = k**2*(p*g1+unit_r*g2*pdotr)*np.exp(-1j*k*norm_R)/(4*np.pi*norm_R)
    return H


def centered_field_in_polar_coords(polar_grid, k):
    """
    k is an array with a value for each frequency.
    the polar grid is also an array with shape of (3, grid_shape)
    """
    polar_grid = polar_grid[..., None]
    k = k[None,:]

    r, theta, phi = polar_grid

    jrk = 1j*r*k
    exp4r = np.exp(-jrk)/(4*np.pi*r)


    Hr = 1j*2*k*np.cos(theta)*(1+jrk**-1)/r*exp4r
    Htheta = -k**2*np.sin(theta)*(1+jrk**-1+jrk**-2)*exp4r
    Hphi = np.zeros(Hr.shape)

    return np.stack([Hr, Htheta, Hphi], axis=0)











########################################################################
########################################################################

def inf_dipole_field(k, p, r, r0):
    """
    This function returns the Electric Field generated by a Hertian Dipole.
    k is the wavenumber => in general it is a complex number.
    p is the electric dipole moment => it has 3 directions px, py and pz, each component is complex. 
    r is the observation point => (x,y,z)
    r0 is the location of the dipole => (x0, y0, z0)
    """
    
    R = np.subtract(np.transpose(r), r0).T # in this way r and r0 can be lists
    # the shape of the R tensor is (#num of dimesions, Xpoints, Ypoints, Zpoints)
    norm_R = np.sqrt(np.einsum("i...,i...", R, R))
    # the spatial dimension is the outermost. So i..., i... will eliminate the first dimension.
    # therefore the output shape is (Xpoints, Ypoints, Zpoints)
    
    # get unit vectors that point in the direction of R
    unit_r = R / norm_R # take advantage of numpy broadcasting
    
    
    ## formula 
    # FarField: k^2 (unit_r x p) x unit_r exp(-jk norm(R))/norm(R)
    
    rxp = np.cross(unit_r, p, axisa=0, axisc=0) 
    # the vector a should use the axis 0 for the 1D cross operation between vectors
    # the output keeps the most external value as the spatial dimensions
    rxpxr = np.cross(rxp, unit_r, axisa=0, axisb=0, axisc=0)
    
    Far_Field = rxpxr*(k**2*(np.exp(-k*1j*norm_R))/norm_R)/(4*np.pi) 
    # some errors.. maybe round off at 10e-5
    
    # Near Field: (3[p Â° unit_r] unit_r - p)(1/norm_R^3+jk/norm_R^2)exp(-jkr)
    c1 = 3*(np.tensordot(p, unit_r, axes=1))*unit_r
    tensor_component =np.subtract(c1.T, np.array(p)).T
    # the result has shape (#n_dimensions, Xpoints, Ypoints, Zpoints)
    Near_Field = tensor_component*(norm_R**-3+k*1j*norm_R**-2)*np.exp(-1j*k*norm_R)/(4*np.pi)    
    return Near_Field, Far_Field