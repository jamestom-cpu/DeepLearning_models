import numpy as np
import math as m
import torch
from my_packages.classes import dipole_fields, dipole_array

import copy


class TorchSolutions():
    def __init__(self, k:torch.tensor, r:torch.tensor, r0: torch.tensor, orientations: torch.tensor, dipole_moments: None):
        self.k = k
        self.r = r
        if dipole_moments is not None:
            self.dipole_moments = dipole_moments
        self.r0 = r0
        self.orientations =orientations
        self.GreenSolutions = GreenSolutions(self.k, self.r, self.r0, self.orientations)
        self.GreenSolutions.over_PEC_for_amplitudes = self._solution_for_amplitudes_with_images
    
    def get_field(self):
        return get_field_from_moment_magnitudes(self.dipole_moments, self.GreenSolutions.for_moment_amplitude())

    def get_field_over_PEC(self):
        return get_field_from_moment_magnitudes(self.dipole_moments, self.GreenSolutions.over_PEC_for_amplitudes())
    
    def _solution_for_amplitudes_with_images(self, ground_plane_height=0):
        orientations = self.get_image_orientations()
        positions = self.get_image_positions(ground_plane_height)


        image_green_solution = self.GreenSolutions.for_moment_amplitude(r0=positions, orientations=orientations)
        free_space_solution = self.GreenSolutions.for_moment_amplitude()
        return image_green_solution+free_space_solution


    def get_image_orientations(self):
        """
        For magnetic dipole sources the image dipoles of:

        - Horizontal Dipoles => Oriented In the Same Direction
        - Vertical Dipoles => Oriented in Opposite Direction
        
        """
        orientations = self.orientations
        image_orientation = torch.stack([np.pi - orientations[:, 0], orientations[:, 1]], axis=1)
        return image_orientation


    def get_image_positions(self, ground_plane_height=0):
        dipole_positions = self.r0.clone()
        delta = torch.concatenate([torch.zeros(dipole_positions.shape[0], 2), 2*(ground_plane_height-dipole_positions[:,-1][:,None])], axis=1)
        dipole_positions = dipole_positions + delta
        return dipole_positions


class GreenSolutions():
    def __init__(self, k:torch.tensor, r:torch.tensor, r0=None, orientations=None):
        self.k = k
        self.r = r
        self.r0 = r0
        self.orientations=orientations
    
    def dyadic_for_vector_moments_single_dipole(self, r0, scale_with_wave_number=True):
        return greens_functions_solution_dyad(k=self.k, r=self.r, r0=r0, scale_with_wave_number=scale_with_wave_number)
    
    def for_set_single_dipole_orientation(self, r0, orientations, scale_with_wave_number = True):
        return greens_solution_for_moment_amplitude(k=self.k, r=self.r, r0=r0, orientations=orientations, scale_with_wave_number=scale_with_wave_number)
    
    def dyadic_for_vector_moment_array(self, r0=None, scale_with_wave_number=True):
        if r0 is None:
            r0 = self.r0
        green_sols = [self.dyadic_for_vector_moments_single_dipole(position, scale_with_wave_number) for position in r0]
        return torch.stack(green_sols, axis=0)
    
    def for_moment_amplitude(self, r0=None, orientations=None, scale_with_wave_number=True):
        if r0 is None:
            r0 = self.r0
        if orientations is None:
            orientations = self.orientations
        green_sols = [self.for_set_single_dipole_orientation(position, orients, scale_with_wave_number) for position, orients in zip(r0, orientations)]
        return torch.stack(green_sols, axis=0)
    



def greens_solution_for_moment_amplitude(k, r, r0, orientations, scale_with_wave_number=True):
    G = greens_functions_solution_dyad(k,r,r0,scale_with_wave_number)
    theta, phi = orientations
    x = torch.sin( theta ) * torch.cos( phi )
    y = torch.sin( theta ) * torch.sin( phi )
    z = torch.cos( theta )

    unit_p = torch.stack([x,y,z], axis=0)    
    return torch.einsum("j, j...", unit_p.type(torch.complex128), G)



def greens_functions_solution_dyad(k, r, r0, scale_with_wave_number=True):
    """
    From dyadic application of maxwell equations, for a uniform space properties, the magentic field 
    generated by a Hertial dipole is: H = k^2 <G(r-r0), m>. 

    For simplicity this function actually returns the k^2 G(r-r0) dyad. Therefore, the solution field can be 
    calculated by applying a dot multiplication over the FIRST dimension

    In order to solve for multiple frequencies, the wave factor is actually an array. The frequency dimension will be kept as the 
    rightmost frequency
    """
    r = r[..., None]
    k = k[None, ...]


    R = r.permute(*torch.arange(r.ndim - 1, -1, -1)) - r0
    R = R.permute(*torch.arange(R.ndim - 1, -1, -1))
    norm_R = torch.linalg.norm(R, axis=0)
    unit_r = R/norm_R

    g1 = 1 - 1j/(k*norm_R) - 1/(k*norm_R)**2
    g2 = -1 + 3j/(k*norm_R) + 3/(k*norm_R)**2

    exponential_component = torch.exp(-1j*k*norm_R)/(4*m.pi*norm_R)

    # get dyadic components
    identity_dyadic = torch.diag(torch.ones(3)).reshape([3,3]+list(torch.ones(len(norm_R.shape), dtype=int)))
    unit_rr_dyadic = torch.einsum("i..., j...",unit_r, unit_r)
    unit_rr_dyadic = torch.moveaxis(unit_rr_dyadic, [-1,-2], [0,1])

    green_solution_dyadic = exponential_component*(g1*identity_dyadic+g2*unit_rr_dyadic)


    return (green_solution_dyadic*k**2 if scale_with_wave_number else green_solution_dyadic)


def get_field_from_moment_magnitudes(sources: torch.tensor, G: torch.tensor):
    return torch.einsum("j...k, j...k -> ...k", G.type(torch.complex128), sources.type(torch.complex128))




